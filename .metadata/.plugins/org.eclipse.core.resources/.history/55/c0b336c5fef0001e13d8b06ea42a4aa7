package daily_0402;

import java.io.*;
import java.util.*;

/**
 * @author 정유진
 * 문제: SW_4193_수영대회결승전
 * 난이도: D3
 * 수행결과: Pass
 * 메모리: 22632 KB
 * 시간: 112 ms
 * 코드길이: 2198 B
 * 풀이 전략: 1) bfs(queue)를 이용 - 이때 time 단위로 자르므로 while문 앞에 현재 q.size()만큼 반복
 * 			2) bfs(queue)를 이용 - pq 이용 안하면 먼저 도착하지만 시간이 큰 경우가 있을 수 있다. comparable 사용.
 * 
 *  */

public class SW_4193_수영대회결승전 {

	//좌표+시간 담을 class
	//pq를 사용하기 위해 comparable 설정
	public static class Node implements Comparable<Node>{
		int x,y,time;

		public Node(int x, int y, int time) {
			super();
			this.x = x;
			this.y = y;
			this.time = time;
		}

		@Override
		public int compareTo(Node o) {
			return this.time-o.time; //오름차순
		}
		
	}
	
	public static int n;
	public static int[][] map;
	public static boolean[][] visited;
	public static int[][] dir= {{-1,0},{0,1},{1,0},{0,-1}};
	public static Node start,end;

	public static void main(String[] args) throws IOException{
		
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st;
		int tc=Integer.parseInt(br.readLine());
		
		for(int t=1;t<=tc;t++) {
			
			n=Integer.parseInt(br.readLine());
			map=new int[n][n];
			visited=new boolean[n][n];
			for(int i=0;i<n;i++) {
				st=new StringTokenizer(br.readLine());
				for(int j=0;j<n;j++) {
					map[i][j]=Integer.parseInt(st.nextToken());
				}
			}
			
			st=new StringTokenizer(br.readLine());
			start=new Node(Integer.parseInt(st.nextToken()),Integer.parseInt(st.nextToken()),0);
			
			st=new StringTokenizer(br.readLine());
			end=new Node(Integer.parseInt(st.nextToken()),Integer.parseInt(st.nextToken()),0);
			
			//int time=pq_bfs();
			int time=bfs();
			System.out.println("#"+t+" "+time);
			
		}

	}
	
	public static int pq_bfs() {
		
		PriorityQueue<Node> pq=new PriorityQueue<>(); //class를 만드는 이유가 pq를 하기 위해서
		
		//pq에 넣고 + 방문 확인
		pq.add(start);
		visited[start.x][start.y]=true;
		while(!pq.isEmpty()) {
			Node tmp=pq.poll();
			
			if(tmp.x==end.x && tmp.y==end.y) {
				return tmp.time;
			}
			
			for(int d=0;d<4;d++) {
				int dx=tmp.x+dir[d][0];
				int dy=tmp.y+dir[d][1];
								
				//배열 범위 벗어나거나, 방문했거나, 벽이라면 pass
				if(dx<0 || dx>=n || dy<0 || dy>=n || map[dx][dy]==1 || visited[dx][dy]) continue;
				
				
				if(map[dx][dy]==0) { //이동가능한 길
					pq.offer(new Node(dx,dy,tmp.time+1));
					visited[dx][dy]=true;
					
				}else if(map[dx][dy]==2) { //소용돌이가 있다면
					pq.offer(new Node(dx,dy,tmp.time+(3-tmp.time%3))); 
					visited[dx][dy]=true;
				}		
				
			}
		}
		
		return -1;

	}
	
	public static int bfs() {
		Queue<Node> q=new ArrayDeque<>();
		int time=0;
		
		q.add(start);
		visited[start.x][start.y]=true;
		
		while(!q.isEmpty()) {
			
			int size=q.size();
			for(int step=0;step<size;step++) {
				
				Node tmp=q.poll();
				if(tmp.x==end.x && tmp.y==end.y) return time;
				
				for(int d=0;d<4;d++) {
					int dx=tmp.x+dir[d][0];
					int dy=tmp.y+dir[d][1];
					
					if(dx<0 || dx>=n || dy<0 || dy>=n || map[dx][dy]==1 || visited[dx][dy])  continue;
					
					if(map[dx][dy]==2 && time%3 !=2) { //소용돌이가 있고 움직일 수 없는 시간이라면
						q.add(new Node(tmp.x,tmp.y,0)); //현재 위치 다시 q에 넣는다
					}else { //벽 제외하고 모두 움직일 수 있다
						q.add(new Node(dx,dy,0)); //이동하고 q에 넣는다
						visited[dx][dy]=true; //방문확인
						
					}
				}
	
			}
			time++; //한 텀이 모두 움직이면 시간 증가

		}
		
		return -1;
		
	}
	


}
