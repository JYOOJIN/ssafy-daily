package daily_0206;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.NoSuchElementException;
import java.util.StringTokenizer;

/**
 * @author 정유진
 * 문제: SW_1233_사칙연산 유효성 검사
 * 난이도: D4
 * 수행결과: Pass
 * 메모리: 22092 KB
 * 시간: 135 ms
 * 코드길이: 1513 B
 * 풀이 전략: 트리의 구조를 이해해야 하기 보다는 어떤 경우에 연산이 되지 않는지, 조건을 따지는게 더 중요!!!!!
 * 			배열에 넣어서 index로 부모,자식을 따져보려 했으나 문제에서 친절하게 자식 노드를 같이 적어주었으므로
 * 			입력할때 조건을 따져보았다.
 * 			<연산 가능한 경우>
 * 			1. 현재 노드가 연산자라면, 자식은 한개 이상의 숫자를 가져야한다
 * 			
 */

public class SW_1233 {
	
	public static boolean isNum(String s) {
		try {
			Integer.parseInt(s);
			return true;
		}catch(Exception e) {
			return false;
		}
		
	}

	public static void main(String[] args) throws NumberFormatException, IOException {
		
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st;
		String[] tree;
		
		for(int t=1;t<=10;t++) {
			int n=Integer.parseInt(br.readLine());
			int flag=0;
			tree=new String[n+1]; //0index를 사용하지 않고 index가 1~n까지이기 때문
			
			for(int i=1;i<=n;i++) {
				st=new StringTokenizer(br.readLine());
				int num=Integer.parseInt(st.nextToken());
				String c=st.nextToken(); //현재 노드 원소
				try {
					String lc=st.nextToken(); //왼쪽 자식 원소
					String rc=st.nextToken(); //오른쪽 자식 원소
					if(c=="-" ||c=="+"||c=="*"||c=="/") { //입력받은 값이 연산자라면
						if(!isNum(lc) && !isNum(rc)) {
							flag++;
						}
					}
				}catch(NoSuchElementException e) {
					if(!isNum(c)) { //숫자가 아니라면
						flag++;
					}
				}
		
			}
			
			if(flag>0) System.out.println("#"+t+" "+0);
			else System.out.println("#"+t+" "+1);
		
		}
		
		
	}

}


